function [Q, R, ind_qr, crit_measure, multipliers, tol_multipliers] = ...
        l1_confirm_constraints(fmodel, cmodel, ind_eactive, ind_qr, ...
                               Q, R, mu, x, bl, bu, Lambda)

    while true
        pseudo_gradient = l1_pseudo_gradient(fmodel.g, mu, ...
                                             cmodel, ...
                                             ind_qr, true);
        crit_measure = l1_criticality_measure(x, pseudo_gradient, Q, R, bl, bu, ...
                                   [cmodel(ind_qr).c]');
        if crit_measure > Lambda
            % No use calculating multipliers
            multipliers = [];
            tol_multipliers = 0;
            break
        end
        [multipliers, tol_multipliers] = ...
            l1_estimate_multipliers(fmodel, cmodel, ...
                                    mu, ind_qr, Q, R, x, bl, bu);
        if isempty(find(multipliers < -tol_multipliers ...
                         | mu < multipliers - tol_multipliers, 1))
            % Multipliers already on correct range
            break
        else
            % Need to drop a constraint
            [Q, R, N, ind_qr, ind_eactive] = ...
                l1_drop_constraint(cmodel, Q, R, ind_qr, ind_eactive, mu, ...
                                   multipliers, tol_multipliers);
        end
    end
end
        